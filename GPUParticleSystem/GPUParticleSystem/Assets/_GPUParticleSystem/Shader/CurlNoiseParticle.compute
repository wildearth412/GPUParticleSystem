// Each #kernel tells which function to compile; you can have many kernels.
#pragma kernel CSInit
#pragma kernel CSUpdate

#define NUM_THREAD_X 8
#define NUM_THREAD_Y 1
#define NUM_THREAD_Z 1

#define PI 3.14159265

#include "Assets/_GPUParticleSystem/Shader/Noise.cginc"
//#include "Assets/_GPUParticleSystem/Shader/AnimTexture.cginc"

// Struct of particle data.
struct ParticleData
{
	float3 velocity;
	float3 position;
	float lifespan;
	float age;      // age : 0 ~ 1
};

// Constant value buffer.
cbuffer CB
{
	int _EmitterType;
	float _EmitterSize;
	bool _UseVertexAnimation;   // If use vertex animation for mesh emitter.
	float _AnimLength;          // Animation length in sec.
	int _AnimTexelSizeY;        // Animation texture pixel size.
	int _VertexCount;           // The count of emitter mesh vertices.
	int _NoiseType;
	float _NoiseAmount;
	float _Time;                // Current time since level load.
	float _TimeStep;            // Current delta time.
	float _MaxLifeSpan;
	float _MinLifeSpan;
	float3 _Gravity;
	float _Speed;
	//float3 _AreaSize;
};

// Create a readable and writable particles data buffer.
RWStructuredBuffer<ParticleData> _ParticleBuffer;

// Create a buffer to store static mesh emitter vertex position.
StructuredBuffer<float3> _VertexPositionBuffer;

// Create a RenderTexture (with enableRandomWrite flag) and set it with cs.SetTexture. 
//RWTexture2D<float4> _VertexPosTex;
Texture2D<float4> _VertexPosTex;

// Function that returns a random value from 0 to 1.0
float rand(float2 v)
{
	return frac(sin(dot(v.xy, float2(12.9898, 78.233))) * 43758.5453);
}

// Function that returns a random point inside a unit sphere.
float3 randomInsideUnitSphere(float2 v)
{
	float phi = 2 * PI * rand(v);
	float th = acos(1.0 - 2.0 * rand(v + float2(0.0,0.1)));
	float r = pow(rand(v + float2(0.0, 0.2)), 0.333333333);

	float x = r * sin(th) * cos(phi);
	float y = r * sin(th) * sin(phi);
	float z = r * cos(th);

	return float3 (x,y,z);
}

float4 getAnimTexColor(int idx)
{
	int u = idx + 1;
	int v = fmod(_Time / _AnimLength, 1.0) * _AnimTexelSizeY;
	return _VertexPosTex[float2(u, v)];
}

float3 getNoise(float3 v)
{
	float3 noiseFactor = float3(0,0,0);
	if (_NoiseType == 1)
	{
		noiseFactor = GetCurlNoise(v) * _NoiseAmount;
	}
	return noiseFactor;
}

//
// ----------- Kernel Functions. -----------
//
[numthreads(NUM_THREAD_X, NUM_THREAD_Y, NUM_THREAD_Z)]  // Set num of threads.
void CSInit(uint3 Gid  : SV_GroupID,
			uint3 GTid : SV_GroupThreadID,
			uint3 DTid : SV_DispatchThreadID,
			uint  GI   : SV_GroupIndex)
{
	// The index of particles.
	int idx = DTid.x;

	float3 velocity = float3(0,0,0);
	float3 position = float3(0,0,0);

	if (_EmitterType == 0)          // Plane.
	{
		position = float3((rand(float2(idx * 1.41325, idx + _Time)) * 2.0 - 1.0), 0, (rand(float2(idx + 0.24312, idx * frac(_Time))) * 2.0 - 1.0)) * _EmitterSize;
		velocity = float3((rand(float2(idx * 1.2432, idx + frac(_Time)))) * 2.0 - 1.0, 1.0 - rand(float2(idx + _Time, idx * 0.3421)) * 0.5, (rand(float2(idx + 4.42312, idx * 2.2314 * frac(_Time)))) * 2.0 - 1.0);
	}
	else if (_EmitterType == 1)     // Sphere.
	{
		float3 rnd = randomInsideUnitSphere(float2(idx, 0));
		position = rnd * _EmitterSize;
		velocity = rnd;
	}
	else if (_EmitterType == 2)     // Mesh.
	{
		// Get random index in emitter mesh vertices indeies.
		int idxv = floor(rand(float2(idx, 4.231 * frac(_Time))) * _VertexCount);
		if (_UseVertexAnimation)
		{
			// Init the particle position with a random vertex postion in animation.
			position = getAnimTexColor(idxv) * _EmitterSize;
		}
		else
		{
			// Init the particle position with a random vertex postion.
			position = _VertexPositionBuffer[idxv] * _EmitterSize;
		}
		
		velocity = float3((rand(float2(idx * 1.2432, idx + frac(_Time))) * 2.0 - 1.0), 1.0 - rand(float2(idx + _Time, idx * 0.3421)) * 0.5, (rand(float2(idx + 4.42312, idx * 2.2314 * frac(_Time))) * 2.0 - 1.0));
	}

	if (_NoiseType != 0)
	{
		float3 n = getNoise(position * 0.5);
		velocity += n;
	}
	
	_ParticleBuffer[idx].velocity = velocity;
	_ParticleBuffer[idx].position = position;

	float lifespan = _MinLifeSpan + rand(float2(idx, 0)) * (_MaxLifeSpan - _MinLifeSpan);
	_ParticleBuffer[idx].lifespan = lifespan;
	_ParticleBuffer[idx].age = 1.0;
}

[numthreads(NUM_THREAD_X, NUM_THREAD_Y, NUM_THREAD_Z)]  // Set num of threads.
void CSUpdate(uint3 Gid  : SV_GroupID,
			  uint3 GTid : SV_GroupThreadID, 
			  uint3 DTid : SV_DispatchThreadID,
			  uint  GI   : SV_GroupIndex)
{
	// The index of particles.
	int idx = DTid.x;
	// Read the speed of particles.
	float3 velocity = _ParticleBuffer[idx].velocity;
	// Read the position of particles.
	float3 position = _ParticleBuffer[idx].position;
	// Read the lifespan and age of particles.
	float lifespan = _ParticleBuffer[idx].lifespan;
	float age = _ParticleBuffer[idx].age;

	// Calculate the acceleration.
	float3 acceleration = _Gravity.xyz;
	// Calculate the speed.
	velocity += acceleration * _TimeStep;
	// Calculate the postion.
	position += velocity * _TimeStep * _Speed;
	// Calculate the age.
	age = (lifespan * age - _TimeStep) / lifespan;

	if (age <= 0)
	{
		// Reset speed, position and lifespan.		
		if (_EmitterType == 0)          // Plane.
		{
			position = float3( (rand(float2(idx * 1.41325, idx + _Time)) * 2.0 - 1.0), 0, (rand(float2(idx + 0.24312, idx * frac(_Time))) * 2.0 - 1.0) ) * _EmitterSize;
			velocity = float3((rand(float2(idx * 1.2432, idx + frac(_Time)))) * 2.0 - 1.0, 1.0 - rand(float2(idx + _Time, idx * 0.3421)) * 0.5, (rand(float2(idx + 4.42312, idx * 2.2314 * frac(_Time)))) * 2.0 - 1.0);
		}
		else if (_EmitterType == 1)     // Sphere.
		{
			float3 rnd = randomInsideUnitSphere(float2(idx, 0));			
			position = rnd * _EmitterSize;
			velocity = rnd;
		}
		else if (_EmitterType == 2)     // Mesh.
		{
			// Get random index in emitter mesh vertices indeies.
			int idxv = floor(rand(float2(idx, 4.231 * frac(_Time))) * _VertexCount);
			if (_UseVertexAnimation)
			{
				// Init the particle position with a random vertex postion in animation.
				position = getAnimTexColor(idxv) * _EmitterSize;
			}
			else
			{
				// Init the particle position with a random vertex postion.
				position = _VertexPositionBuffer[idxv] * _EmitterSize;
			}
			
			velocity = float3((rand(float2(idx * 1.2432, idx + frac(_Time))) * 2.0 - 1.0), 1.0 - rand(float2(idx + _Time, idx * 0.3421)) * 0.5, (rand(float2(idx + 4.42312, idx * 2.2314 * frac(_Time))) * 2.0 - 1.0));
		}

		lifespan = _MinLifeSpan + rand(float2(idx, 0)) * (_MaxLifeSpan - _MinLifeSpan);
		_ParticleBuffer[idx].lifespan = lifespan;
		age = 1.0;
	}

	if (_NoiseType != 0)
	{
		// Apply noise.
		float3 n = getNoise(position * 0.5);
		velocity += n;
	}
	
	// Write speed, position and lifespan into buffer.
	_ParticleBuffer[idx].velocity = velocity;
	_ParticleBuffer[idx].position = position;
	_ParticleBuffer[idx].age = age;

	//Result[id.xy] = float4(DTid.x & DTid.y, (DTid.x & 15)/15.0, (DTid.y & 15)/15.0, 0.0);
}
